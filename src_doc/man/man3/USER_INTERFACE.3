.TH "USER_INTERFACE" 3 "Mon Feb 24 2014" "Version V1" "EMS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
USER_INTERFACE \- 
.PP
.PP
  

.in +1c
.ti -1c
.RI "int8_t \fBwait_new_conversion\fP (void)"
.br
.RI "\fI.PP
 \fP"
.in -1c
.in +1c
.ti -1c
.RI "int16_t \fBmain\fP (int argc, const char **argv)"
.br
.RI "\fI.PP
 \fP"
.in -1c
.in +1c
.ti -1c
.RI "void \fBreading_loop\fP (void)"
.br
.RI "\fI.PP
 \fP"
.in -1c
.in +1c
.ti -1c
.RI "int8_t \fBsave_to_file\fP (uint16_t rpi_address, \fBmeasured_data_t\fP data, const char *fileName, uint8_t clean)"
.br
.RI "\fI.PP
 \fP"
.in -1c
.in +1c
.ti -1c
.RI "int16_t \fBconfig_recheck\fP (const char *config_file, const char *format,\&.\&.\&.)"
.br
.RI "\fI.PP
 \fP"
.in -1c
.SH "Detailed Description"
.PP 
.PP
 USER INTERFACE
Top most module in the application, responsible for handling commands received 
.br
 from the shell or via config\&.csv file\&.
.PP
In order that, the program runs accordingly\&.:
.PP
.PP
.nf
[executable] + command .fi
.PP
 
.br
 The followoing requests are supported:
.PP
.PP
.nf
driver_ade7880  config .fi
.PP
.PP
-> Runs Default configuration procedure\&. As described in the device datasheet section QUICK SETUP AS ENERGY METER 
.br
 (Outputs resulting message to consol on success or failure\&.)
.br

.br
.PP
.PP
.nf
driver_ade7880  read  [register phisical address (HEX eg. 0xFFFF)] [register size in byte (decimal)]  .fi
.PP
 -> Reads Specific register value 
.br
 (Outputs resulting message to consol on success or failure)
.br

.br
.PP
.PP
.nf
driver_ade7880  write [register phisical address (HEX eg. 0xFFFF)] [value to be stored (HEX eg. 0xFFFF)] [register size in byte (decimal)]  .fi
.PP
 -> Writes the given value to Specific register 
.br
 (Outputs resulting message to consol on success or failure)
.br

.br
.PP
.PP
.nf
driver_ade7880  run .fi
.PP
 -> Runs the normal program execution routine 
.br
 (Outputs resulting message to consol on success or failure\&.)
.br

.br
.PP
There are also common commands between Python script and this module used to alter the normal 
.br
 execution routine via common configuration csv format interface file \&. i\&.e\&. the program continuously 
.br
 Monitor this file so as to act accordingly if there is any change\&.
.PP
The structure of the command used is simple 
.br
.PP
.PP
.nf
id(int);fileName;Sampling_Rate(uint32_t);loop_control(bool);pause(bool)
   |      |           |                       |                    |
   |      |           |                       |                    |___ Control flag: 
   |      |           |                       |                           if set to 1 pause reading
   |      |           |                       |                           and set to 0 resume reading
   |      |           |                       |________________________ Control flag: 
   |      |           |                                                   if set to 1, the program will
   |      |           |                                                   exit reading loop and end execution    
   |      |           |________________________________________________ Delay_control: 
   |      |                                                               Adds the specified number of
   |      |                                                               millsecond delay on the    
   |      |                                                               main reading loop
   |      |____________________________________________________________ Sets file name 
   |                                                                    where data to be saved   
   |___________________________________________________________________ Sets device id  .fi
.PP
 
.SH "Function Documentation"
.PP 
.SS "int16_t config_recheck (const char *config_file, const char *format, \&.\&.\&.)"

.PP
.PP
 \fBParameters:\fP
.RS 4
\fIconfig_file\fP pointer to the file Name array 
.br
\fIformat\fP String format specifying configuration command structure 
.br
 anything used on printf function can also be used here 
.br
\fI\&.\&.\&.\fP the function expects at least as many additional arguments 
.br
 as specified by format\&.
.RE
.PP
Function reads the specified file and fills into passed arguments\&.
.PP
\fBReturns:\fP
.RS 4
function return 0 or -1, on success or failure respectively\&. 
.PP
 
.RE
.PP

.PP
Definition at line 482 of file ade7880_driver\&.c\&.
.PP
Referenced by reading_loop()\&.
.PP
.nf
483 {
484     
485    int16_t result;
486    int16_t ii,cc;
487    FILE *f =fopen(config_file,'r');
488    if (f == NULL) return -1; 
489    
490   char cmd_line[100];
491   va_list args;
492   va_start (args, format);
493    
494   if(fgets(cmd_line,100,f)!=NULL){
495       for(ii=0,cc=0;*(cmd_line+ii)!='\0';ii++)
496         if(*(cmd_line+ii)==';'){*(cmd_line+ii)= ' '; ++cc;}
497     
498     result=vsscanf (cmd_line, format, args);
499     result = (result == cc)?0:-1;
500   }
501   
502   va_end (args);
503   fclose(f); 
504   return result;
505 }
.fi
.SS "int16_t main (intargc, const char **argv)"

.PP
.PP
 \fISubroutine:main\fP program subroutine
.PP
\fBParameters:\fP
.RS 4
\fIargc\fP number of arguments sent from the shell 
.br
\fIargv\fP pointer to the argument buffer
.RE
.PP
Function commonly perform library Initialization, Setup Rpi gpio and spi interface\&. Then run the requested procedure based on the argument passed from shall\&.
.PP
\fBReturns:\fP
.RS 4
function return 0 or -1, on success or failure respectively\&. 
.PP
 
.RE
.PP

.PP
Definition at line 198 of file ade7880_driver\&.c\&.
.PP
References ade7880_config_reg_default(), ade7880_power_mode(), CHIP_ADDRESS1, config_cmd(), DISABLE, ENABLE, make16(), make8(), PIN_SS, PSM0, reading_loop(), rpi_gpio_init(), SET_RAM_WR_PROTECTION, spi_init(), spi_read(), and spi_write()\&.
.PP
.nf
198                                          {
199     
200      
201      
202     int8_t cc =0;
203     int16_t result =-1;
204     
205     struct timeval tv;
206 
207      if((argc < 1)|| !bcm2835_init()/*library has to be initialized*/)   
208            return -1;    
209      
210     rpi_gpio_init();
211     ade7880_power_mode(PSM0);
212     usleep(50);
213     
214     if(spi_init(BCM2835_SPI_CS0)!= 0)
215     return -1;
216         #ifdef DEBUG 
217         uint16_t cp=0;
218         printf('\n#######################################%d###################################################\n',cp++);
219         #endif
220      
221     
222      if(strcmp (argv[1],'config')==0)
223      {
224         if(ade7880_config_reg_default()!=-1)
225               printf('\nDevice Ready to use\n');
226      } 
227      else 
228      if(strcmp(argv[1],'read')==0)   
229      {
230         if(argc<4){printf('\nCMD ERROR: RD\n');return-1;}
231           
232         for(cc = 0;cc<((argc>=5)?atoi(argv[4]):1);cc++){
233          spi_read(BCM2835_SPI_CS0,CHIP_ADDRESS1,make16((uint8_t *)argv[2],2),atoi(argv[3]));
234          gettimeofday(&tv,NULL);
235          printf('<----------------------------------------------------------- %d timesamp: %lf\n',
236          cc+1,(double)(tv\&.tv_sec + tv\&.tv_usec/(double)10E6));
237         }
238      return 0;
239      }
240      else 
241      if(strcmp(argv[1],'write')==0 )
242      {
243         if(argc<4){printf('\nCMD ERROR: WR\n');return-1;}
244     int ii;
245        for(ii=0;ii<argc;ii++)
246             printf(' argval %d, = %s',ii,argv[ii]);
247         
248         result=0;cc = 0;while(((result = config_cmd(SET_RAM_WR_PROTECTION,1,DISABLE))== -1)&& (cc++ < 3)); 
249         if(spi_write(BCM2835_SPI_CS0,CHIP_ADDRESS1,make16((uint8_t *)argv[2],2)
250         ,make8((uint8_t *)argv[3],2),atoi(argv[4]))!=0)
251           result =-1;
252          result=0;cc = 0;while(((result = config_cmd(SET_RAM_WR_PROTECTION,1,ENABLE))== -1)&& (cc++ < 3)); 
253          if(result == -1){
254                     printf('ERROR: Couldn't write');  
255                       return -1;
256          }
257          
258      return 0;
259      }
260      else
261      if(strcmp(argv[1],'run')==0) 
262      {
263         #ifdef DEBUG
264         if(argc >=3){
265            if((strcmp(argv[2],'dprint=off')==0))
266                spi_enable_msg_debug_print(DISABLE);
267             else if((strcmp(argv[2],'dprint=on')==0))
268                 spi_enable_msg_debug_print(ENABLE);
269         }   
270         printf('\n#######################################%d###################################################\n',cp++);
271         #endif
272         
273         if(argc<2){printf('\nCMD ERROR: measure\n');return-1;} 
274            
275            reading_loop();
276      }
277 
278      
279      bcm2835_spi_end();
280        
281      bcm2835_gpio_write(PIN_SS, HIGH);
282        
283      bcm2835_close();
284      
285 return 0;
286 }
.fi
.SS "void reading_loop (void)"

.PP
.PP
 Function reads measured values of main interest form ADE7880, checks the 
.br
 current configuration command form config\&.csv, and saves the data to the 
.br
 specified interface file\&. The configuration command affect the behavior 
.br
 at which this subroutine execute, please use this document for more detail\&.
.PP
\fBReturns:\fP
.RS 4
none\&. 
.PP
 
.RE
.PP
\fBNote:\fP
.RS 4
on startup new file will be used to save data, 
.br
 otherwise data will be appended to the existing 
.br
 interface file\&. 
.br
 This is required due to the reason that, after power down 
.br
 on reset the file could be corrupted\&.
.RE
.PP

.PP
Definition at line 302 of file ade7880_driver\&.c\&.
.PP
References ade7880_config_reg_default(), CONFIG_CMD_FORMAT, CONFIG_FILE_NAME, config_recheck(), ENABLE, phase_data_t::IRMS, measure(), PHASE_A, measured_data_t::phase_a, PHASE_ACTIVE_POWER, PHASE_ACTIVE_WH, PHASE_B, measured_data_t::phase_b, PHASE_C, measured_data_t::phase_c, PHASE_IRMS, PHASE_VRMS, phase_data_t::POWER, save_to_file(), phase_data_t::VRMS, and phase_data_t::WH\&.
.PP
Referenced by main()\&.
.PP
.nf
302                        {
303 
304   int16_t   rpi_address; 
305   char *    filename;
306   uint32_t  cyc_time;
307   uint8_t   loop_ctrl;
308   uint8_t   pause;
309   int8_t    result=0;
310   int8_t startup = 1;
311   
312     measured_data_t data;
313     
314         #ifdef DEBUG 
315         printf('\n\n');
316         #endif  
317          printf('\nEntering Main loop \&.\&.\&.\n');
318          while(1){  
319          printf('\n');
320          
321          printf('\nReading Phase A values \&.\&.\&.\n');  
322          if((data\&.phase_a\&.IRMS            = measure(PHASE_IRMS,PHASE_A,100))==-1)result = -1;
323          if((data\&.phase_a\&.VRMS            = measure(PHASE_VRMS,PHASE_A,100))==-1)result = -1;
324          if((data\&.phase_a\&.WH          = measure(PHASE_ACTIVE_WH,PHASE_A,1))==-1)result = -1;
325          if((data\&.phase_a\&.POWER           = measure(PHASE_ACTIVE_POWER,PHASE_A,1))==-1)result = -1;
326          
327          printf('\nReading Phase B values \&.\&.\&.\n'); 
328          if((data\&.phase_b\&.IRMS            = measure(PHASE_IRMS,PHASE_B,100))==-1)result = -1;
329          if((data\&.phase_b\&.VRMS            = measure(PHASE_VRMS,PHASE_B,100))==-1)result = -1;
330          if((data\&.phase_b\&.WH          = measure(PHASE_ACTIVE_WH,PHASE_B,1))==-1)result = -1;
331          if((data\&.phase_b\&.POWER           = measure(PHASE_ACTIVE_POWER,PHASE_B,1))==-1)result = -1;
332          
333          printf('\nReading Phase C values \&.\&.\&.\n'); 
334          if((data\&.phase_c\&.IRMS            = measure(PHASE_IRMS,PHASE_C,100))==-1)result = -1;
335          if((data\&.phase_c\&.VRMS            = measure(PHASE_VRMS,PHASE_C,100))==-1)result = -1;
336          if((data\&.phase_c\&.WH          = measure(PHASE_ACTIVE_WH,PHASE_C,1))==-1)result = -1;
337          if((data\&.phase_c\&.POWER           = measure(PHASE_ACTIVE_POWER,PHASE_C,1))==-1)result = -1;
338          
339         printf('\n\n\nREADINGS:\n');
340         printf('\n');       
341         printf('\n---------------------------------------------------------------------PHASE A KWH  : %f\n',data\&.phase_a\&.WH);
342         printf('\n---------------------------------------------------------------------PHASE A POWER: %f\n',data\&.phase_a\&.POWER);
343         printf('\n---------------------------------------------------------------------PHASE A VRMS : %f\n',data\&.phase_a\&.VRMS);
344         printf('\n---------------------------------------------------------------------PHASE A IRMS : %f\n',data\&.phase_a\&.IRMS);
345         printf('\n');
346         printf('\n---------------------------------------------------------------------PHASE B KWH  : %f\n',data\&.phase_b\&.WH);
347         printf('\n---------------------------------------------------------------------PHASE B POWER: %f\n',data\&.phase_b\&.POWER);
348         printf('\n---------------------------------------------------------------------PHASE B VRMS : %f\n',data\&.phase_b\&.VRMS);
349         printf('\n---------------------------------------------------------------------PHASE B IRMS : %f\n',data\&.phase_b\&.IRMS);
350         printf('\n');
351         printf('\n---------------------------------------------------------------------PHASE C KWH  : %f\n',data\&.phase_c\&.WH);
352         printf('\n---------------------------------------------------------------------PHASE C POWER: %f\n',data\&.phase_c\&.POWER);
353         printf('\n---------------------------------------------------------------------PHASE C VRMS : %f\n',data\&.phase_c\&.VRMS);
354         printf('\n---------------------------------------------------------------------PHASE C IRMS : %f\n',data\&.phase_c\&.IRMS);
355                      
356         if(result == -1){            
357             ade7880_config_reg_default(); //this is the only thing we do for now
358         //  continue;
359         }
360         
361         do{
362         if(config_recheck (CONFIG_FILE_NAME,CONFIG_CMD_FORMAT,&rpi_address ,filename, &cyc_time,&loop_ctrl,&pause)==0){
363         
364         if(pause==0){
365         
366           while(save_to_file(rpi_address,data, filename,
367           startup 
376           )!=0)
377         
378           startup = 0; 
379           
380          }
381          
382          }
383          
384          usleep(cyc_time);
385         }while(pause==1);
386          
387         if(loop_ctrl == 1)
388         break;
389         
390         
391         
392                 
393         #ifdef DEBUG
394         if(result!=-1)
395         printf('\nREADING SUCESS\n');
396         spi_enable_msg_debug_print(ENABLE);
397         #endif
398         
399         
400      }
401 
402 }
.fi
.SS "int8_t save_to_file (uint16_trpi_address, \fBmeasured_data_t\fPdata, const char *fileName, uint8_tclean)"

.PP
.PP
 \fBParameters:\fP
.RS 4
\fIrpi_address\fP address of the Rpi 
.br
\fIdata\fP data structure with the data to be saved to the file 
.br
\fIfileName\fP pointer to the fileName array 
.br
\fIclean\fP boolean flag, if 0 data will be appended to the file, if 1 new file will be used
.RE
.PP
function saves data to the specified file in csv file format\&.
.PP
\fBReturns:\fP
.RS 4
function return 0 or -1, on success or failure respectively\&. 
.PP
 
.RE
.PP

.PP
Definition at line 421 of file ade7880_driver\&.c\&.
.PP
References DUMMY_MSG, phase_data_t::IRMS, measured_data_t::phase_a, measured_data_t::phase_b, measured_data_t::phase_c, phase_data_t::POWER, phase_data_t::VRMS, and phase_data_t::WH\&.
.PP
Referenced by reading_loop()\&.
.PP
.nf
422 { 
423 uint32_t dummy=0;
424   FILE *f = fopen(fileName, (clean == 1)?'w':'a');  
425   errno = 0;
426   if (f == NULL){ 
427    warn('%s: Couldn't open file %s; %s\n',fileName, strerror (errno));
428   
429   return -1;
430   }
431   
432   
433   fprintf(f, '%d;%lu;%f;%f;%f;%f;%f;%f;%f;%f;%f;%f;%f;%f;%d;%d;%d;%d;%d;%d\n', 
434           rpi_address,
435           (unsigned)time(NULL),
436     
437                data\&.phase_a\&.IRMS,     
438                data\&.phase_a\&.VRMS,     
439                data\&.phase_a\&.WH,           
440                data\&.phase_a\&.POWER,    
441                 
442                data\&.phase_b\&.IRMS,     
443                data\&.phase_b\&.VRMS,     
444                data\&.phase_b\&.WH,           
445                data\&.phase_b\&.POWER,
446 
447                data\&.phase_c\&.IRMS,     
448                data\&.phase_c\&.VRMS,     
449                data\&.phase_c\&.WH,           
450                data\&.phase_c\&.POWER,                    
451                DUMMY_MSG,
452                DUMMY_MSG,    
453                DUMMY_MSG,   
454                DUMMY_MSG,
455                DUMMY_MSG,              
456                DUMMY_MSG                
457   ); 
458  
459   
460   fclose(f); 
461   return 0; 
462 } 
.fi
.SS "int8_t wait_new_conversion (void)"

.PP
.PP
 Function clears STATUS0 register Data-Ready bit and waits until the DSP set 
.br
 it back again\&. this verifies new reading is loaded to value registers\&.
.PP
\fBReturns:\fP
.RS 4
function return 0 or -1 on success or failure respectively\&. 
.PP
 
.RE
.PP

.PP
Definition at line 122 of file ade7880_driver\&.c\&.
.PP
References CHIP_ADDRESS1, config_cmd(), DISABLE, ENABLE, status0_reg_u::reg_all, SET_RAM_WR_PROTECTION, spi_read(), spi_write(), and STATUS0\&.
.PP
Referenced by measure()\&.
.PP
.nf
122                                 {
123 
124            int8_t cc =0;
125            int16_t result =-1;
126     
127            struct timeval tv;
128            status0_reg_u status0;
129            status0\&.reg_all = spi_read(BCM2835_SPI_CS0,CHIP_ADDRESS1,STATUS0,sizeof(uint32_t));
130           
131            
132         
133            if(status0\&.bits\&.DREADY==1){
134     
135            result=0;cc = 0;while(((result = config_cmd(SET_RAM_WR_PROTECTION,1,DISABLE))== -1)&& (cc++ < 3));   
136            //put back the value to clears status flags         
137            if(spi_write(BCM2835_SPI_CS0,CHIP_ADDRESS1,STATUS0,status0\&.reg_all,sizeof(uint32_t))!=0)result =-1; 
138            status0\&.reg_all = spi_read(BCM2835_SPI_CS0,CHIP_ADDRESS1,STATUS0,sizeof(uint32_t));
139            result=0;cc = 0;while(((result = config_cmd(SET_RAM_WR_PROTECTION,1,ENABLE))== -1)&& (cc++ < 3)); 
140          
141            
142            if(result == -1){
143                     printf('\nERROR: Couldn't write\n');  
144                     return -1;
145            }
146            
147             
148            }
149            
150            
151            
152         
153            gettimeofday(&tv,NULL);
154            uint32_t t1,t2;
155            t1=t2 = tv\&.tv_usec;   
156            #ifdef DEBUG            
157            printf('\nSTATUS REG VALUE %08X,-------------------------------------------- us time %lu\n',status0\&.reg_all,t1);
158            #endif
159            while(status0\&.bits\&.DREADY==0){ //wait till conversion is done
160          
161              status0\&.reg_all = spi_read(BCM2835_SPI_CS0,CHIP_ADDRESS1,STATUS0,sizeof(uint32_t));
162              gettimeofday(&tv,NULL);
163              
164              t2 = tv\&.tv_usec;    
165              #ifdef DEBUG 
166              printf('\nSTATUS REG VALUE %08X,-------------------------------------------- us time %lu\n',status0\&.reg_all,t2);  
167              #endif
168              if((t2-t1)>20000)
169              return -1;
170              
171            }
172            
173            
174 
175   return 0;
176 }
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for EMS from the source code\&.
