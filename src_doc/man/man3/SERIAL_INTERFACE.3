.TH "SERIAL_INTERFACE" 3 "Mon Feb 24 2014" "Version V1" "EMS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
SERIAL_INTERFACE \- 
.PP
.PP
.PP
.PP
  

.in +1c
.ti -1c
.RI "int8_t \fBspi_rd_wr\fP (uint8_t chip_select, uint8_t *tx_buffer, uint16_t len)"
.br
.RI "\fI.PP
 \fP"
.in -1c
.in +1c
.ti -1c
.RI "uint32_t \fBspi_read\fP (uint8_t chip_select, uint8_t chip_address, uint16_t \fBtarget_register\fP, uint8_t reg_len)"
.br
.RI "\fI.PP
 \fP"
.in -1c
.in +1c
.ti -1c
.RI "int8_t \fBspi_write\fP (uint8_t chip_select, uint8_t chip_address, uint16_t \fBtarget_register\fP, int32_t \fBvalue\fP, uint8_t reg_len)"
.br
.in -1c
.in +1c
.ti -1c
.RI "int8_t \fBspi_ram_protection\fP (uint8_t cmd, uint8_t chip_address)"
.br
.RI "\fI.PP
 \fP"
.in -1c
.SH "Detailed Description"
.PP 
.PP
.PP
.PP
 

SERIAL INTERFACE
spi driver application layer, The module handles the data transfer between the Rpi and ADE7880":
.PP
.PD 0
.IP "\(bu" 2
The ADE7880 is always a slave of the communication
.PP
.PD 0
.IP "\(bu" 2
The maximum serial clock frequency supported by this interface is 2\&.5 MHz 
.br

.br

.br

.PP
.SH "SPI Read Operation procedure"
.PP
 
.PP
.PD 0
.IP "\(bu" 2
The read operation initiated when SS/HSA pin is set to low and begins sending one byte, 
.br
 representing the address of the chip , on the MOSI line\&. 
.br
 Notice:(Bit 0 of the address byte must be 1 for a read operation) 
.br

.PP
.PD 0
.IP "\(bu" 2
Next, 16-bit address of the register that is read will be sent\&. 
.br

.PP
.PD 0
.IP "\(bu" 2
Then ADE7880 after it receives the last bit of address of the register on a low-to-high 
.br
 transition of SCLK, it begins to transmit its contents on the MISO line when the next 
.br
 SCLK high-to-low transition occurs; 
.br

.PP
.PD 0
.IP "\(bu" 2
After the last bit is received, set the SS and SCLK lines high and the communication ends\&. 
.br

.PP
.PD 0
.IP "\(bu" 2
The data lines, MOSI and MISO, go into a high impedance state\&. 
.br
 
.br

.PP
Please see the datasheet \fBADE7880\fP http://www.analog.com/static/imported-files/data_sheets/ADE7880.pdf for more details\&. 
.br

.br

.br
.SH "SPI Wirte Operation procedure"
.PP
 
.PP
.PD 0
.IP "\(bu" 2
The write operation initiated when SS/HSA pin is set to low and begins sending one byte, 
.br
 representing the address of the chip , on the MOSI line\&. 
.br
 Notice:(Bit 0 of the address byte must be 0 for a read operation) 
.br

.PP
.PD 0
.IP "\(bu" 2
Next, 16-bit address of the register that is written will be sent\&. 
.br

.PP
.PD 0
.IP "\(bu" 2
And then without losing any SCLK cycle, the 32-, 16-, or 8-bit value will be sent 
.br

.PP
.PD 0
.IP "\(bu" 2
After the last bit is received, set the SS and SCLK lines high and the communication ends\&. 
.br

.PP
.PD 0
.IP "\(bu" 2
The data lines, MOSI and MISO, go into a high impedance state\&. 
.br
 
.br

.PP
Please see the datasheet \fBADE7880\fP http://www.analog.com/static/imported-files/data_sheets/ADE7880.pdf for more details\&. 
.SH "Function Documentation"
.PP 
.SS "int8_t spi_ram_protection (uint8_tcmd, uint8_tchip_address)"

.PP
.PP
 \fBParameters:\fP
.RS 4
\fIcmd\fP protection enable/disable command 
.br
\fIchip_select\fP Indicates the selected chip for communication
.RE
.PP
Function runs RAM protection enable or disable procedure on ADE7880 
.br
 the function also verifies the communication by reading the 
.br
 LAST OPERATION,LAST ADDRESS and LAST READ WRITE DATA registers and 
.br
 outputs message to console if there is a failure\&.
.PP
\fBReturns:\fP
.RS 4
function return 0 or -1, on success or failure respectively \&. 
.PP
 
.RE
.PP

.PP
Definition at line 343 of file spi_ade7880_protocol\&.c\&.
.PP
References address_byte_ut::address_all, ade7880_ram_lock_msg_ut::address_byte, ADE7880_WR, address_byte_ut::bits, CHIP_ADDRESS1, DISABLE, ENABLE, LAST_ADD, LAST_OP, LAST_RWDATA8, RAM_LOCK_MSG_LENGTH, address_byte_ut::RD_WR, spi_read(), value, and ade7880_ram_lock_msg_ut::value\&.
.PP
.nf
343                                                            {
344       
345       
346     int8_t result = 0;  
347     
348     uint8_t value = (cmd==ENABLE)?0x80:0x00;
349     
350      ade7880_ram_lock_msg_ut tx_buff_1st_msg,tx_buff_2nd_msg;
351 
352      tx_buff_1st_msg\&.msg_fields\&.address_byte\&.address_all = chip_address;
353      tx_buff_1st_msg\&.msg_fields\&.address_byte\&.bits\&.RD_WR = ADE7880_WR;
354      tx_buff_1st_msg\&.msg_fields\&.target_register = htons(0xE7FE);
355      tx_buff_1st_msg\&.msg_fields\&.value = 0xAD;
356      
357      
358      tx_buff_2nd_msg\&.msg_fields\&.address_byte\&.address_all = chip_address;
359      tx_buff_2nd_msg\&.msg_fields\&.address_byte\&.bits\&.RD_WR = ADE7880_WR;
360      tx_buff_2nd_msg\&.msg_fields\&.target_register = htons(0xE7E3);
361      tx_buff_2nd_msg\&.msg_fields\&.value = value;
362      
363 
364     #ifdef DEBUG
365        if(debug_print&0x01){
366        printf('\nMSG SENT: WR\n');
367        printf('       Chip Address %02X\n',
368        tx_buff_1st_msg\&.msg_fields\&.address_byte\&.address_all);
369        printf('       1st Target Register %04X\n',
370        ntohs(tx_buff_1st_msg\&.msg_fields\&.target_register)
371        );
372        printf('       Value sent 1st  %1X\n',
373        ntohl(tx_buff_1st_msg\&.msg_fields\&.value));
374        
375        printf('       2nd Target Register %04X\n',
376        ntohs(tx_buff_2nd_msg\&.msg_fields\&.target_register)
377        );
378        printf('       Value sent  %01X\n',
379        ntohl(tx_buff_2nd_msg\&.msg_fields\&.value));
380        }
381     #endif
382 
383     
384     bcm2835_spi_transfern(tx_buff_1st_msg\&.msg_all,RAM_LOCK_MSG_LENGTH);
385     bcm2835_spi_transfern(tx_buff_2nd_msg\&.msg_all,RAM_LOCK_MSG_LENGTH);
386 
387     
388     uint8_t  result8  =0;
389     uint16_t result16 =0;
390     
391      #ifdef DEBUG 
392      if(!(debug_print&0x80))
393      debug_print = DISABLE;
394        printf('\nvarifying last operation  \&.\&.\&.\n');
395      #endif
396      if((result8 =(uint8_t)(spi_read(BCM2835_SPI_CS0,CHIP_ADDRESS1,LAST_OP,sizeof(uint16_t))))
397      !=0xCA /*LAST_OP!=WR*/){
398              
399      #ifdef DEBUG
400        printf('\n                                               <---  WR failure : LAST_OP \n');
401        printf('        LAST_OP value  :%02X\n',result8);   
402      #endif
403      result = -1;
404      }else{
405       #ifdef DEBUG
406        printf('        LAST_OP value  :%02X\n',result8);   
407      #endif
408      }
409      
410      #ifdef DEBUG
411        printf('\nvarifying last accessed register  \&.\&.\&.\n');
412      #endif
413      if((result16 =(uint16_t)(spi_read(BCM2835_SPI_CS0,CHIP_ADDRESS1,LAST_ADD,sizeof(uint16_t))))!=0xE7E3){
414              
415      #ifdef DEBUG
416        printf('\n                                               <---  WR failure : LAST_ADD\n');
417        printf('        Target Register :%04X\n', 0xE7E3);
418        printf('        LAST_ADD value  :%04X\n',result16);   
419      #endif
420      result = -1;
421      }else{
422       #ifdef DEBUG
423         printf('       LAST_ADD value  :%04X\n',result16); 
424       #endif
425      }
426      
427     
428      #ifdef DEBUG
429        printf('\nvarifying last accessed register  value:\n');
430      #endif
431 
432      result8 = (uint8_t)(spi_read(BCM2835_SPI_CS0,CHIP_ADDRESS1,LAST_RWDATA8,sizeof(uint8_t))&0x000000FF);
433     
434 
435      if(result8!=value)
436          result = -1;   
437      #ifdef DEBUG
438        if(result8!=value)
439        printf('\n                                               <---  WR failure : LAST_RWDATA\n');
440        printf('       Sent Value        :%01X\n', value);
441        printf('       LAST_RWDATA value :%01X\n',result8);   
442        
443        if(!(debug_print&0x80))
444            debug_print = ENABLE;
445      #endif
446 
447      
448      
449     return result;
450 }   
.fi
.SS "int8_t spi_rd_wr (uint8_tchip_select, uint8_t *tx_buffer, uint16_tlen)"

.PP
.PP
 \fBParameters:\fP
.RS 4
\fIchip_select\fP Indicates the selected chip for communication 
.br
\fItx_buffer\fP Pointer to transmit buffer 
.br
\fIlen\fP length of the data
.RE
.PP
initalizes spi of RPi , sends out data from tx_buffer and also receive back data into rc_buffer and end spi to return the normal gpio functionality\&.
.PP
\fBReturns:\fP
.RS 4
function return 0 or -1, on success or failure respectively\&. 
.PP
 
.RE
.PP

.PP
Definition at line 114 of file spi_ade7880_protocol\&.c\&.
.PP
References PIN_SS, and spi_init()\&.
.PP
.nf
115 {
116    
117        
118        if(!spi_init(chip_select)){
119     
120           bcm2835_spi_transfern(tx_buffer,sizeof(tx_buffer));      
121           return 0;       
122        }else
123           return -1;
124     
125        bcm2835_spi_end();
126        
127        bcm2835_gpio_write(PIN_SS, HIGH);       
128 }
.fi
.SS "uint32_t spi_read (uint8_tchip_select, uint8_tchip_address, uint16_ttarget_register, uint8_treg_len)"

.PP
.PP
 \fBParameters:\fP
.RS 4
\fIchip_select\fP Indicates the selected chip for communication 
.br
\fIchip_address\fP the chip address or id of the used ADE7880 
.br
\fItarget_register\fP the address of the register to read from 
.br
\fIreg_len\fP the size of the register in byte
.RE
.PP
reads the specified register value from the selected ade7880 chip, according to the recommended SPI read Operation procedure, see the device datasheet for more detail\&.
.PP
\fBReturns:\fP
.RS 4
function return ther resulting value on success and on failure 0x0F000000\&. 
.PP
.RE
.PP
\fBParameters:\fP
.RS 4
\fIchip_select\fP Indicates the selected chip for communication 
.br
\fIchip_address\fP the chip address or id of the used ADE7880 
.br
\fItarget_register\fP the address of the register to update 
.br
\fIvalue\fP value to be written 
.br
\fIreg_len\fP the size of the register in byte
.RE
.PP
update the specified register value on the selected ade7880 chip 
.br
 according to the recommended SPI write Operation procedure, 
.br
 see the device datasheet for more detail 
.br
 the function will also verify the communication by reading the 
.br
 LAST OPERATION,LAST ADDRESS and LAST READ WRITE DATA registers and 
.br
 outputs message to console if there is a failure\&.
.PP
\fBRemarks:\fP
.RS 4
the function dosen't consider 24bit signed value regisers on the device, 
.br
 if it become necessory to wright to regisers of this kind remember to modify\&.
.RE
.PP
\fBReturns:\fP
.RS 4
function return 0 or -1, on success or failure respectively \&. 
.PP
 
.RE
.PP

.PP
Definition at line 147 of file spi_ade7880_protocol\&.c\&.
.PP
References address_byte_ut::address_all, ade7880_read_tx_buff_ut::address_byte, ADE7880_RD, address_byte_ut::bits, DUMMY_MSG, RD_MSG_LENGTH, address_byte_ut::RD_WR, ade7880_read_tx_buff_ut::reg16, ade7880_read_tx_buff_ut::reg32, and ade7880_read_tx_buff_ut::reg8\&.
.PP
Referenced by main(), measure(), spi_ram_protection(), spi_write(), and wait_new_conversion()\&.
.PP
.nf
147                                                                                                     {
148    
149   uint32_t result= 0;
150 
151     ade7880_read_tx_buff_ut tx_buff;
152     
153     tx_buff\&.msg_fields\&.address_byte\&.address_all = chip_address;
154     tx_buff\&.msg_fields\&.address_byte\&.bits\&.RD_WR = ADE7880_RD;
155     tx_buff\&.msg_fields\&.target_register = htons(target_register);
156     tx_buff\&.msg_fields\&.value\&.reg32 = DUMMY_MSG;
157 
158     #ifdef DEBUG
159      if((debug_print&0x01)){
160        printf('\nMSG SENT  : RD\n');
161        
162        printf('        Chip Address %02X\n',tx_buff\&.msg_fields\&.address_byte\&.address_all);
163        printf('        Target Register %04X\n',ntohs(tx_buff\&.msg_fields\&.target_register));
164        printf('        DUMMY %08X \n',tx_buff\&.msg_fields\&.value\&.reg32);
165        }
166     #endif
167     
168     bcm2835_spi_transfern(tx_buff\&.msg_all,RD_MSG_LENGTH + reg_len);  
169     
170     
171               
172     
173     
174     
175     result =  (reg_len == sizeof(uint32_t))?((uint32_t)ntohl(tx_buff\&.msg_fields\&.value\&.reg32))
176              :((reg_len == sizeof(uint16_t))?((uint32_t)ntohs(tx_buff\&.msg_fields\&.value\&.reg16))
177              :((reg_len == sizeof(uint8_t))?((uint32_t)tx_buff\&.msg_fields\&.value\&.reg8):0x0F000000/*ERROR*/));
178     
179     
180     #ifdef DEBUG
181      if(debug_print&0x01 || 1){
182        printf('\nMSG REPLAY : RD\n');
183        printf('        REPLAY :%X\n',result);
184      }  
185     #endif
186     
187     
188 
189 
190     return result;
191     
192 }
.fi
.SS "int8_t spi_write (uint8_tchip_select, uint8_tchip_address, uint16_ttarget_register, int32_tvalue, uint8_treg_len)"

.PP
Definition at line 221 of file spi_ade7880_protocol\&.c\&.
.PP
References address_byte_ut::address_all, ade7880_write_tx_buff_ut::address_byte, ADE7880_WR, address_byte_ut::bits, CHIP_ADDRESS1, DISABLE, ENABLE, LAST_ADD, LAST_OP, LAST_RWDATA16, LAST_RWDATA32, LAST_RWDATA8, address_byte_ut::RD_WR, ade7880_write_tx_buff_ut::reg16, ade7880_write_tx_buff_ut::reg32, ade7880_write_tx_buff_ut::reg8, spi_read(), value, and WR_MSG_LENGTH\&.
.PP
Referenced by main(), and wait_new_conversion()\&.
.PP
.nf
221                                                                                                                  {
222       
223       
224     int8_t result = 0;  
225     ade7880_write_tx_buff_ut  tx_buff;
226 
227      tx_buff\&.msg_fields\&.address_byte\&.address_all = chip_address;
228      tx_buff\&.msg_fields\&.address_byte\&.bits\&.RD_WR = ADE7880_WR;
229      tx_buff\&.msg_fields\&.target_register = htons(target_register);
230      
231     if(reg_len == sizeof(uint8_t))
232       tx_buff\&.msg_fields\&.value\&.reg8  = (uint8_t)value;
233     else if(reg_len == sizeof(uint16_t))
234       tx_buff\&.msg_fields\&.value\&.reg16 = htons((uint16_t)value);
235     else if(reg_len == sizeof(uint32_t))
236       tx_buff\&.msg_fields\&.value\&.reg32 = htonl((uint32_t)value);
237     
238     #ifdef DEBUG
239       if(debug_print&0x01){
240        printf('\nMSG SENT: WR\n');
241        printf('       Chip Address %02X\n',
242        tx_buff\&.msg_fields\&.address_byte\&.address_all);
243        printf('       Target Register %04X\n',
244        ntohs(tx_buff\&.msg_fields\&.target_register));
245        printf('       Value sent  %08X\n',
246        ntohl(tx_buff\&.msg_fields\&.value\&.reg32));
247        }
248     #endif
249 
250     bcm2835_spi_transfern(tx_buff\&.msg_all,WR_MSG_LENGTH + reg_len);
251     
252 
253     
254     uint8_t  result8  =0;
255     uint16_t result16 =0;
256     int32_t result32 =0;    
257     
258      #ifdef DEBUG 
259      if(!(debug_print&0x80))
260      debug_print = DISABLE;
261        printf('\nvarifying last operation  \&.\&.\&.\n');
262      #endif
263      if((result8 =(uint8_t)(spi_read(BCM2835_SPI_CS0,CHIP_ADDRESS1,LAST_OP,sizeof(uint16_t))))
264      !=0xCA /*LAST_OP!=WR*/){
265              
266      #ifdef DEBUG
267        printf('\n                                               <---  WR failure : LAST_OP \n');
268        printf('        LAST_OP value  :%02X\n',result8);   
269      #endif
270      result = -1;
271      }else{
272       #ifdef DEBUG
273        printf('        LAST_OP value  :%02X\n',result8);   
274      #endif
275      }
276      
277      #ifdef DEBUG
278        printf('\nvarifying last accessed register  \&.\&.\&.\n');
279      #endif
280      if((result16 =(uint16_t)(spi_read(BCM2835_SPI_CS0,CHIP_ADDRESS1,LAST_ADD,sizeof(uint16_t))))!=target_register){
281              
282      #ifdef DEBUG
283        printf('\n                                               <---  WR failure : LAST_ADD\n');
284        printf('        Target Register :%04X\n', target_register);
285        printf('        LAST_ADD value  :%04X\n',result16);   
286      #endif
287      result = -1;
288      }else{
289       #ifdef DEBUG
290         printf('       LAST_ADD value  :%04X\n',result16); 
291       #endif
292      }
293      
294     
295      #ifdef DEBUG
296        printf('\nvarifying last accessed register  value:\n');
297      #endif
298     if(reg_len == sizeof(uint8_t)){
299         result32 = (int32_t)(spi_read(BCM2835_SPI_CS0,CHIP_ADDRESS1,LAST_RWDATA8,sizeof(uint8_t))&0x000000FF);
300     }else   
301     if(reg_len == sizeof(uint16_t)){
302         result32 = (int32_t)(spi_read(BCM2835_SPI_CS0,CHIP_ADDRESS1,LAST_RWDATA16,sizeof(uint16_t))&0x0000FFFF);
303     }else
304     if(reg_len == sizeof(uint32_t)){
305         result32 = (int32_t)(spi_read(BCM2835_SPI_CS0,CHIP_ADDRESS1,LAST_RWDATA32,sizeof(uint32_t)));       
306     }   
307     //if 
308 
309      if(result32!=value)
310          result = -1;   
311      #ifdef DEBUG
312        if(result32!=value)
313        printf('\n                                               <---  WR failure : LAST_RWDATA\n');
314        printf('       Sent Value        :%08X\n', value);
315        printf('       LAST_RWDATA value :%08X\n',result32);   
316       if(!(debug_print&0x80))
317        debug_print = ENABLE;
318      #endif
319      
320      
321     return result;
322 }   
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for EMS from the source code\&.
